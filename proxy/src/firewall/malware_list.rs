use std::{fmt, sync::Arc, time::Duration};

use arc_swap::{ArcSwap, Guard};
use radix_trie::Trie;
use rama::{
    Service,
    error::{ErrorContext, OpaqueError},
    graceful::ShutdownGuard,
    http::{BodyExtractExt, Request, Response, Uri, service::client::HttpClientExt as _},
    telemetry::tracing,
    utils::str::arcstr::ArcStr,
};
use rand::Rng;
use semver::Version;
use serde::{Deserialize, Serialize};
use tokio::time::Instant;

use crate::storage::SyncCompactDataStorage;

#[derive(Clone)]
pub struct RemoteMalwareList {
    trie: Arc<ArcSwap<MalwareTrie>>,
}

impl fmt::Debug for RemoteMalwareList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RemoteMalwareList").finish()
    }
}

impl RemoteMalwareList {
    pub async fn try_new<C>(
        guard: ShutdownGuard,
        uri: Uri,
        refresh_interval: Duration,
        sync_storage: SyncCompactDataStorage,
        client: C,
    ) -> Result<Self, OpaqueError>
    where
        C: Service<Request, Output = Response, Error = OpaqueError>,
    {
        let filename = url_to_filename(&uri);

        let client = RemoteMalwareListClient {
            uri,
            filename,
            refresh_interval,
            sync_storage,
            client,
        };

        let malware_trie = match client.download_malware_trie().await {
            Ok(trie) => {
                tracing::trace!(
                    "create new remote malware list (uri: {}) with fresh trie",
                    client.uri
                );
                trie
            }
            Err(err) => {
                tracing::error!(
                    "failed to create new remote malware list (uri: {}) with fresh trie; try to load cached trie; err = {err}",
                    client.uri
                );
                client.load_cached_malware_trie().await?
            }
        };

        let shared_malware_trie = Arc::new(ArcSwap::new(Arc::new(malware_trie)));

        tokio::spawn(remote_list_update_loop(
            guard,
            client,
            shared_malware_trie.clone(),
        ));

        Ok(Self {
            trie: shared_malware_trie,
        })
    }
}

struct RemoteMalwareListClient<C> {
    uri: Uri,
    filename: ArcStr,
    refresh_interval: Duration,
    sync_storage: SyncCompactDataStorage,
    client: C,
}

impl<C> RemoteMalwareListClient<C>
where
    C: Service<Request, Output = Response, Error = OpaqueError>,
{
    async fn download_malware_trie(&self) -> Result<MalwareTrie, OpaqueError> {
        let start = Instant::now();

        let malware_list: Vec<ListDataEntry> = self
            .client
            .get(self.uri.clone())
            .send()
            .await
            .with_context(|| {
                format!(
                    "fetch malware list from remote endpoint '{}'; (tt: {:?})",
                    self.uri,
                    start.elapsed()
                )
            })?
            .try_into_json()
            .await
            .with_context(|| {
                format!(
                    "collect and json-decode malware list response payload from remote endpoint '{}'; (tt: {:?})",
                    self.uri,
                    start.elapsed(),
                )
            })?;

        tracing::debug!(
            "fetched and decoded and new malware list from remote endpoint '{}', with {} entries (tt: {:?})",
            self.uri,
            malware_list.len(),
            start.elapsed(),
        );

        // backup in background,
        // only useful for making restarts faster and also
        // less error prone in case at the time the CDN is broken or w/e
        tokio::task::spawn_blocking({
            let storage = self.sync_storage.clone();
            let filename = self.filename.clone();
            let malware_list = malware_list.clone();

            move || {
                if let Err(err) = storage.store(&filename, &malware_list) {
                    tracing::error!(
                        "failed to backup downloaded malware list @ '{filename}': {err}"
                    )
                }
            }
        });

        let trie = trie_from_malware_list(malware_list);

        tracing::debug!(
            "malware trie refreshed with link to remote endpoint '{}' (tt: {:?})",
            self.uri,
            start.elapsed(),
        );
        Ok(trie)
    }

    async fn load_cached_malware_trie(&self) -> Result<MalwareTrie, OpaqueError> {
        tokio::task::spawn_blocking({
            let filename = self.filename.clone();
            let storage = self.sync_storage.clone();
            move || {
                let malware_list: Vec<ListDataEntry>  = storage
                    .load(&filename)
                    .context("storage failure")?
                    .context("cached malware list not found")?;

                let trie = trie_from_malware_list(malware_list);

                Ok::<_, OpaqueError>(trie)
            }
        })
        .await
        .with_context(|| {
            format!(
                "wait for blocking task to use cached malware list for creating new remote malware list (failure endpoint: {})",
                self.uri
            )
        })?
        .with_context(|| {
            format!(
                "try to use cached malware list for creating new remote malware list (failure endpoint: {})",
                self.uri
            )
        })
    }
}

async fn remote_list_update_loop<C>(
    guard: ShutdownGuard,
    client: RemoteMalwareListClient<C>,
    shared_malware_trie: Arc<ArcSwap<MalwareTrie>>,
) where
    C: Service<Request, Output = Response, Error = OpaqueError>,
{
    tracing::debug!(
        "remote malware list (uri = {}), update loop task up and running",
        client.uri
    );

    let mut sleep_for = with_jitter(client.refresh_interval);

    loop {
        tracing::debug!(
            "remote malware list (uri = {}), sleep for: {sleep_for:?}",
            client.uri
        );
        tokio::select! {
            _ = tokio::time::sleep(sleep_for) => {},
            _ = guard.cancelled() => {
                tracing::debug!(
                    "remote malware list (uri = {}), guard cancelled; exit",
                    client.uri
                );
                return;
            }
        }

        match client.download_malware_trie().await {
            Ok(fresh_trie_from_bel_air) => {
                tracing::debug!(
                    "remote malware list (uri = {}), malware trie updated",
                    client.uri
                );
                shared_malware_trie.store(Arc::new(fresh_trie_from_bel_air));
                sleep_for = with_jitter(client.refresh_interval);
            }
            Err(err) => {
                tracing::error!(
                    "remote malware list (uri = {}), failed to update (err = {err}), try again in shorter interval...",
                    client.uri
                );
                let fail_interval = Duration::from_secs(std::cmp::min(sleep_for.as_secs() / 2, 60));
                sleep_for = with_jitter(fail_interval);
            }
        }
    }
}

fn with_jitter(refresh: Duration) -> Duration {
    let max_jitter = std::cmp::min(refresh, Duration::from_secs(60));
    let jitter_secs = rand::rng().random_range(0.0..=max_jitter.as_secs_f64());
    refresh + Duration::from_secs_f64(jitter_secs)
}

fn trie_from_malware_list(malware_list: Vec<ListDataEntry>) -> MalwareTrie {
    let mut trie = MalwareTrie::new();
    for list_entry in malware_list.into_iter() {
        let entry = MalwareEntry {
            version: list_entry.version,
            reason: list_entry.reason,
        };
        match trie.get_mut(&list_entry.package_name) {
            Some(entries) => entries.push(entry),
            None => {
                let _previous = trie.insert(list_entry.package_name, vec![entry]);
                debug_assert!(
                    _previous.is_none(),
                    "trie::get_mut should have returned result if it already existed!"
                );
            }
        }
    }
    trie
}

pub struct MalwareEntriesResult<'a> {
    package_name: &'a str,
    guard: Guard<Arc<Trie<String, Vec<MalwareEntry>>>>,
}

impl MalwareEntriesResult<'_> {
    pub fn entries(&self) -> Option<&[MalwareEntry]> {
        self.guard.get(self.package_name).map(|v| v.as_slice())
    }
}

impl RemoteMalwareList {
    pub fn find_entries<'a>(&self, package_name: &'a str) -> MalwareEntriesResult<'a> {
        let guard = self.trie.load();
        MalwareEntriesResult {
            package_name,
            guard,
        }
    }
}

rama::utils::macros::enums::enum_builder! {
    @String
    pub enum Reason {
        Malware => "MALWARE",
        Telemetry => "TELEMETRY",
    }
}

pub type MalwareTrie = Trie<String, Vec<MalwareEntry>>;

pub struct MalwareEntry {
    pub version: Version,
    pub reason: Reason,
}

#[derive(Clone, Serialize, Deserialize)]
struct ListDataEntry {
    package_name: String,
    // NOTE: should you ever have lists that do not use semver versions,
    // you would need to replace the Version type with something that can handle those
    // versions as well... And either you use that also in your MalwareEntry,
    // or you would convert it to a Semver version when collecting the data into the (malware) trie
    version: Version,
    reason: Reason,
}

fn url_to_filename(url: &Uri) -> ArcStr {
    url.to_string()
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .into()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_url_to_filename() {
        let url = Uri::from_static("http://example.com/foo?bar=baz&answer=42");
        let filename = url_to_filename(&url);
        assert_eq!("http___example_com_foo_bar_baz_answer_42", filename);
    }
}
