use std::{borrow::Cow, fmt, str::FromStr, sync::Arc, time::Duration};

use rama::{
    Service,
    error::{ErrorContext, OpaqueError},
    graceful::ShutdownGuard,
    http::{
        BodyExtractExt, Request, Response, StatusCode, Uri, service::client::HttpClientExt as _,
    },
    telemetry::tracing,
    utils::str::arcstr::ArcStr,
};

use arc_swap::{ArcSwap, Guard};
use radix_trie::Trie;
use rand::Rng;
use serde::{Deserialize, Serialize};
use tokio::time::Instant;

use crate::storage::SyncCompactDataStorage;

#[derive(Clone)]
pub struct RemoteMalwareList {
    trie: Arc<ArcSwap<MalwareTrie>>,
}

impl fmt::Debug for RemoteMalwareList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RemoteMalwareList").finish()
    }
}

impl RemoteMalwareList {
    pub async fn try_new<C>(
        guard: ShutdownGuard,
        uri: Uri,
        sync_storage: SyncCompactDataStorage,
        client: C,
    ) -> Result<Self, OpaqueError>
    where
        C: Service<Request, Output = Response, Error = OpaqueError>,
    {
        let filename = url_to_filename(&uri);
        let refresh_interval = Duration::from_mins(10);
        let client = RemoteMalwareListClient {
            uri,
            filename,
            refresh_interval,
            sync_storage,
            client,
        };

        let (malware_trie, e_tag) = match client.load_cached_malware_trie().await {
            Ok(Some(cached_info)) => {
                tracing::debug!(
                    "create new remote malware list (uri: {}) with cached trie",
                    client.uri
                );
                cached_info
            }
            Ok(None) => {
                tracing::debug!(
                    "no cached malware list found for remote endpoint (uri: {}); download fresh list",
                    client.uri
                );

                client
                    .download_malware_trie(None)
                    .await
                    .context("download new malware list")?
                    .context("new malware list not available")?
            }
            Err(err) => {
                tracing::warn!(
                    "failed to load cached malware list for remote endpoint (uri: {}); download fresh list; err = {err}",
                    client.uri
                );

                client
                    .download_malware_trie(None)
                    .await
                    .context("download new malware list")?
                    .context("new malware list not available")?
            }
        };

        let shared_malware_trie = Arc::new(ArcSwap::new(Arc::new(malware_trie)));

        tokio::spawn(remote_list_update_loop(
            guard,
            client,
            e_tag,
            shared_malware_trie.clone(),
        ));

        Ok(Self {
            trie: shared_malware_trie,
        })
    }
}

struct RemoteMalwareListClient<C> {
    uri: Uri,
    filename: ArcStr,
    refresh_interval: Duration,
    sync_storage: SyncCompactDataStorage,
    client: C,
}

impl<C> RemoteMalwareListClient<C>
where
    C: Service<Request, Output = Response, Error = OpaqueError>,
{
    async fn download_malware_trie(
        &self,
        e_tag: Option<&str>,
    ) -> Result<Option<(MalwareTrie, Option<ArcStr>)>, OpaqueError> {
        let Some((malware_list, new_e_tag)) =
            self.fetch_remote_malware_list_and_e_tag(e_tag).await?
        else {
            return Ok(None);
        };

        self.spawn_malware_list_caching_task(malware_list.clone(), new_e_tag.clone());

        let trie = trie_from_malware_list(malware_list);

        tracing::debug!(
            "malware trie refreshed with link to remote endpoint '{}'",
            self.uri,
        );

        Ok(Some((trie, new_e_tag)))
    }

    async fn fetch_remote_malware_list_and_e_tag(
        &self,
        previous_e_tag: Option<&str>,
    ) -> Result<Option<(Vec<ListDataEntry>, Option<ArcStr>)>, OpaqueError> {
        let start = Instant::now();

        let req_builder = self.client.get(self.uri.clone());

        let req_builder = if let Some(e_tag) = previous_e_tag {
            req_builder.header("if-none-match", e_tag)
        } else {
            req_builder
        };

        let resp = req_builder.send().await.with_context(|| {
            format!(
                "fetch malware list from remote endpoint '{}'; (tt: {:?})",
                self.uri,
                start.elapsed()
            )
        })?;

        if resp.status() == StatusCode::NOT_MODIFIED {
            tracing::debug!(
                "malware list endpoint '{}' reported list is not found, return no new list; (tt: {:?})",
                self.uri,
                start.elapsed()
            );
            return Ok(None);
        }

        let e_tag: Option<ArcStr> = resp
            .headers()
            .get("etag")
            .and_then(|v| v.as_bytes().try_into().ok());

        let malware_list: Vec<ListDataEntry> = resp
            .try_into_json()
            .await
            .with_context(|| {
                format!(
                    "collect and json-decode malware list response payload from remote endpoint '{}'; (tt: {:?})",
                    self.uri,
                    start.elapsed(),
                )
            })?;

        tracing::debug!(
            "fetched and decoded and new malware list from remote endpoint '{}', with {} entries (tt: {:?})",
            self.uri,
            malware_list.len(),
            start.elapsed(),
        );

        Ok(Some((malware_list, e_tag)))
    }

    fn spawn_malware_list_caching_task(
        &self,
        malware_list: Vec<ListDataEntry>,
        e_tag: Option<ArcStr>,
    ) {
        let storage = self.sync_storage.clone();
        let filename = self.filename.clone();

        // backup in background,
        // only useful for making restarts faster and also
        // less error prone in case at the time the CDN is broken or w/e
        tokio::task::spawn_blocking(move || {
            if let Err(err) = storage.store(
                &filename,
                &CachedMalwareTrie {
                    e_tag: e_tag.clone(),
                    list: malware_list,
                },
            ) {
                tracing::error!("failed to backup downloaded malware list @ '{filename}': {err}")
            }
        });
    }

    async fn load_cached_malware_trie(
        &self,
    ) -> Result<Option<(MalwareTrie, Option<ArcStr>)>, OpaqueError> {
        tokio::task::spawn_blocking({
            let storage = self.sync_storage.clone();
            let filename = self.filename.clone();
            move || load_cached_malware_trie_sync_inner(storage, filename)
        })
        .await
        .with_context(|| {
            format!(
                "wait for blocking task to use cached malware list for creating new remote malware list (failure endpoint: {})",
                self.uri
            )
        })?
        .with_context(|| {
            format!(
                "try to use cached malware list for creating new remote malware list (failure endpoint: {})",
                self.uri
            )
        })
    }
}

fn load_cached_malware_trie_sync_inner(
    storage: SyncCompactDataStorage,
    filename: ArcStr,
) -> Result<Option<(MalwareTrie, Option<ArcStr>)>, OpaqueError> {
    let cached_malware_trie: Option<CachedMalwareTrie> =
        storage.load(&filename).context("storage failure")?;

    let Some(cached_malware_trie) = cached_malware_trie else {
        return Ok(None);
    };

    let trie = trie_from_malware_list(cached_malware_trie.list);

    Ok(Some((trie, cached_malware_trie.e_tag)))
}

async fn remote_list_update_loop<C>(
    guard: ShutdownGuard,
    client: RemoteMalwareListClient<C>,
    e_tag: Option<ArcStr>,
    shared_malware_trie: Arc<ArcSwap<MalwareTrie>>,
) where
    C: Service<Request, Output = Response, Error = OpaqueError>,
{
    tracing::debug!(
        "remote malware list (uri = {}), update loop task up and running",
        client.uri
    );

    let mut sleep_for = with_jitter(client.refresh_interval);
    let mut latest_e_tag = e_tag;

    loop {
        tracing::debug!(
            "remote malware list (uri = {}), sleep for: {sleep_for:?}",
            client.uri
        );
        tokio::select! {
            _ = tokio::time::sleep(sleep_for) => {},
            _ = guard.cancelled() => {
                tracing::debug!(
                    "remote malware list (uri = {}), guard cancelled; exit",
                    client.uri
                );
                return;
            }
        }

        match client.download_malware_trie(latest_e_tag.as_deref()).await {
            Ok(Some((fresh_trie, fresh_e_tag))) => {
                tracing::debug!(
                    "remote malware list (uri = {}), malware trie updated",
                    client.uri
                );
                shared_malware_trie.store(Arc::new(fresh_trie));
                sleep_for = with_jitter(client.refresh_interval);
                latest_e_tag = fresh_e_tag;
            }
            Ok(None) => {
                tracing::debug!("malware list was unmodified, preserve current one...");
                sleep_for = with_jitter(client.refresh_interval);
            }
            Err(err) => {
                tracing::error!(
                    "remote malware list (uri = {}), failed to update (err = {err}), try again in shorter interval...",
                    client.uri
                );
                let fail_interval = Duration::from_secs(std::cmp::max(sleep_for.as_secs() / 2, 60));
                sleep_for = with_jitter(fail_interval);
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
struct CachedMalwareTrie {
    pub e_tag: Option<ArcStr>,
    pub list: Vec<ListDataEntry>,
}

fn with_jitter(refresh: Duration) -> Duration {
    let max_jitter = std::cmp::min(refresh, Duration::from_secs(60));
    let jitter_secs = rand::rng().random_range(0.0..=max_jitter.as_secs_f64());
    refresh + Duration::from_secs_f64(jitter_secs)
}

fn trie_from_malware_list(malware_list: Vec<ListDataEntry>) -> MalwareTrie {
    let mut trie = MalwareTrie::new();
    for list_entry in malware_list.into_iter() {
        let entry = MalwareEntry {
            version: list_entry.version,
            reason: list_entry.reason,
        };
        match trie.get_mut(&list_entry.package_name) {
            Some(entries) => entries.push(entry),
            None => {
                let _previous = trie.insert(list_entry.package_name, vec![entry]);
                debug_assert!(
                    _previous.is_none(),
                    "trie::get_mut should have returned result if it already existed!"
                );
            }
        }
    }
    trie
}

pub struct MalwareEntriesResult<'a> {
    package_name: &'a str,
    guard: Guard<Arc<Trie<String, Vec<MalwareEntry>>>>,
}

impl MalwareEntriesResult<'_> {
    pub fn entries(&self) -> Option<&[MalwareEntry]> {
        self.guard.get(self.package_name).map(|v| v.as_slice())
    }
}

impl RemoteMalwareList {
    pub fn find_entries<'a>(&self, package_name: &'a str) -> MalwareEntriesResult<'a> {
        let guard = self.trie.load();
        MalwareEntriesResult {
            package_name,
            guard,
        }
    }

    #[cfg(test)]
    pub(crate) fn from_trie_for_test(trie: MalwareTrie) -> Self {
        Self {
            trie: Arc::new(ArcSwap::new(Arc::new(trie))),
        }
    }
}

rama::utils::macros::enums::enum_builder! {
    @String
    pub enum Reason {
        Malware => "MALWARE",
        Telemetry => "TELEMETRY",
    }
}

pub type MalwareTrie = Trie<String, Vec<MalwareEntry>>;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct MalwareEntry {
    pub version: PackageVersion,
    pub reason: Reason,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ListDataEntry {
    pub package_name: String,
    pub version: PackageVersion,
    pub reason: Reason,
}

#[derive(Debug, Clone)]
pub enum PackageVersion {
    /// examples: 1.2.3, 1.0.0-pre.8, 1.0.0-pre8
    Semver(semver::Version),
    /// *
    Any,
    /// Empty or undefined
    None,
    /// Version which failed to be parsed into something known,
    /// keep it here anyway so that breaking changes in version formats,
    /// do not break existing proxies
    Unknown(ArcStr),
}

impl PartialEq for PackageVersion {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Semver(l0), Self::Semver(r0)) => l0 == r0,
            (Self::Unknown(l0), Self::Unknown(r0)) => l0 == r0,
            (Self::Unknown(l0), Self::None) | (Self::None, Self::Unknown(l0)) => {
                l0.trim().is_empty()
            }
            (Self::Any, _) | (_, Self::Any) => true,
            _ => core::mem::discriminant(self) == core::mem::discriminant(other),
        }
    }
}

impl Eq for PackageVersion {}

impl FromStr for PackageVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let s = s.trim();

        if s.is_empty() {
            return Ok(PackageVersion::None);
        }

        if s == "*" {
            return Ok(PackageVersion::Any);
        }

        Ok(match semver::Version::from_str(s) {
            Ok(v) => PackageVersion::Semver(v),
            Err(err) => {
                tracing::trace!(
                    "failed to parse version as None, Any or Semver (err = {err}); return as unknown package version (format)"
                );
                PackageVersion::Unknown(s.into())
            }
        })
    }
}

impl PartialEq<semver::Version> for PackageVersion {
    fn eq(&self, other: &semver::Version) -> bool {
        match self {
            PackageVersion::Semver(v) => v == other,
            PackageVersion::Any => true,
            _ => false,
        }
    }
}

impl PartialEq<PackageVersion> for semver::Version {
    fn eq(&self, other: &PackageVersion) -> bool {
        other.eq(self)
    }
}

impl Serialize for PackageVersion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            PackageVersion::Semver(version) => Some(version).serialize(serializer),
            PackageVersion::Any => Some("*").serialize(serializer),
            PackageVersion::None => Some("").serialize(serializer),
            PackageVersion::Unknown(arc_str) => Some(arc_str).serialize(serializer),
        }
    }
}

impl<'de> Deserialize<'de> for PackageVersion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let maybe_raw = <Option<Cow<'de, str>>>::deserialize(deserializer)?;

        let Some(raw) = maybe_raw else {
            return Ok(PackageVersion::None);
        };

        let Ok(v) = PackageVersion::from_str(&raw);
        Ok(v)
    }
}

/// Display [`Uri`] as a appropriate string for a file name,
/// replacing all non-alphanumeric ASCII characters as an underscore `_`.
fn url_to_filename(url: &Uri) -> ArcStr {
    url.to_string()
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .into()
}

#[cfg(test)]
mod tests {
    use rama::utils::str::arcstr::arcstr;
    use serde_test::{Token, assert_de_tokens, assert_tokens};

    use super::*;

    #[test]
    #[tracing_test::traced_test]
    fn test_url_to_filename() {
        let url = Uri::from_static("http://example.com/foo?bar=baz&answer=42");
        let filename = url_to_filename(&url);
        assert_eq!("http___example_com_foo_bar_baz_answer_42", filename);
    }

    #[test]
    #[tracing_test::traced_test]
    fn test_list_data_entry_without_version() {
        assert_de_tokens(
            &ListDataEntry {
                package_name: "package w/o version (implicit)".to_owned(),
                version: PackageVersion::None,
                reason: Reason::Malware,
            },
            &[
                Token::Struct {
                    name: "ListDataEntry",
                    len: 2,
                },
                Token::String("package_name"),
                Token::String("package w/o version (implicit)"),
                Token::String("reason"),
                Token::String("malware"),
                Token::StructEnd,
            ],
        )
    }

    #[test]
    #[tracing_test::traced_test]
    fn test_list_data_entry_ser_de() {
        for (tokens, entry) in [
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package with semver"),
                    Token::String("version"),
                    Token::Some,
                    Token::String("1.2.3"),
                    Token::String("reason"),
                    Token::String("test"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package with semver".to_owned(),
                    version: PackageVersion::Semver(semver::Version::new(1, 2, 3)),
                    reason: Reason::Unknown("test".to_owned()),
                },
            ),
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package @ any"),
                    Token::String("version"),
                    Token::Some,
                    Token::String("*"),
                    Token::String("reason"),
                    Token::String("TELEMETRY"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package @ any".to_owned(),
                    version: PackageVersion::Any,
                    reason: Reason::Telemetry,
                },
            ),
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package w/o version"),
                    Token::String("version"),
                    Token::Some,
                    Token::String(""),
                    Token::String("reason"),
                    Token::String("MALWARE"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package w/o version".to_owned(),
                    version: PackageVersion::None,
                    reason: Reason::Malware,
                },
            ),
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package with unknown version"),
                    Token::String("version"),
                    Token::Some,
                    Token::String("V20-3020#32;123"),
                    Token::String("reason"),
                    Token::String("MALWARE"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package with unknown version".to_owned(),
                    version: PackageVersion::Unknown(arcstr!("V20-3020#32;123")),
                    reason: Reason::Malware,
                },
            ),
        ] {
            assert_tokens(&entry, &tokens);
        }
    }

    #[test]
    fn test_package_version_eq() {
        for (version_a, version_b, is_eq) in [
            (PackageVersion::Any, PackageVersion::Any, true),
            (
                PackageVersion::Unknown(arcstr!("foo")),
                PackageVersion::Any,
                true,
            ),
            (
                PackageVersion::Any,
                PackageVersion::Unknown(arcstr!("foo")),
                true,
            ),
            (PackageVersion::Any, PackageVersion::None, true),
            (
                PackageVersion::Unknown(arcstr!("foo")),
                PackageVersion::Unknown(arcstr!("foo")),
                true,
            ),
            (
                PackageVersion::Unknown(arcstr!("Foo")),
                PackageVersion::Unknown(arcstr!("foo")),
                false,
            ),
            (
                PackageVersion::Unknown(arcstr!("foo")),
                PackageVersion::Unknown(arcstr!("Foo")),
                false,
            ),
            (
                PackageVersion::Unknown(arcstr!("foo")),
                PackageVersion::Unknown(arcstr!("hello")),
                false,
            ),
            (
                PackageVersion::Semver(semver::Version::new(1, 2, 3)),
                PackageVersion::Unknown(arcstr!("hello")),
                false,
            ),
            (
                PackageVersion::Unknown(arcstr!("hello")),
                PackageVersion::Semver(semver::Version::new(1, 2, 3)),
                false,
            ),
            (
                PackageVersion::Semver(semver::Version::new(4, 2, 3)),
                PackageVersion::Semver(semver::Version::new(4, 2, 3)),
                true,
            ),
            (
                PackageVersion::Semver(semver::Version::new(1, 2, 3)),
                PackageVersion::Semver(semver::Version::new(2, 2, 3)),
                false,
            ),
            (
                PackageVersion::Semver(semver::Version::new(1, 2, 3)),
                PackageVersion::Semver(semver::Version::new(1, 2, 4)),
                false,
            ),
        ] {
            assert_eq!(is_eq, version_a == version_b)
        }
    }
}
