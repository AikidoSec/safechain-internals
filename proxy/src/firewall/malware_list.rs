use std::{fmt, sync::Arc, time::Duration};

use rama::{
    Service,
    error::{BoxError, ErrorContext},
    graceful::ShutdownGuard,
    http::{
        BodyExtractExt, Request, Response, StatusCode, Uri, service::client::HttpClientExt as _,
    },
    telemetry::tracing,
    utils::str::arcstr::ArcStr,
};

use arc_swap::{ArcSwap, Guard};
use radix_trie::Trie;
use rand::RngExt as _;
use serde::{Deserialize, Serialize};
use tokio::time::Instant;

use crate::{firewall::version::PackageVersion, storage::SyncCompactDataStorage};

pub trait MalwareListEntryFormatter: Send + Sync {
    /// Map a raw malware-list entry into the trie lookup key.
    ///
    /// This is called only when (re)building the trie
    fn format(&self, entry: &ListDataEntry) -> String;
}

pub(in crate::firewall) struct LowerCaseEntryFormatter;
impl MalwareListEntryFormatter for LowerCaseEntryFormatter {
    fn format(&self, entry: &ListDataEntry) -> String {
        entry.package_name.trim().to_ascii_lowercase()
    }
}

#[derive(Debug, Default)]
struct IdentityEntryFormatter;

impl MalwareListEntryFormatter for IdentityEntryFormatter {
    fn format(&self, entry: &ListDataEntry) -> String {
        entry.package_name.to_owned()
    }
}

pub type EntryFormatter = Arc<dyn MalwareListEntryFormatter>;

#[derive(Clone)]
pub struct RemoteMalwareList {
    trie: Arc<ArcSwap<MalwareTrie>>,
}

impl fmt::Debug for RemoteMalwareList {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RemoteMalwareList").finish()
    }
}

impl RemoteMalwareList {
    pub async fn try_new<C>(
        guard: ShutdownGuard,
        uri: Uri,
        sync_storage: SyncCompactDataStorage,
        client: C,
        formatter: Option<EntryFormatter>,
    ) -> Result<Self, BoxError>
    where
        C: Service<Request, Output = Response, Error = BoxError>,
    {
        let entry_formatter = formatter.unwrap_or_else(|| Arc::new(IdentityEntryFormatter));

        let filename = url_to_filename(&uri);
        let refresh_interval = Duration::from_mins(10);
        let client = RemoteMalwareListClient {
            uri,
            filename,
            refresh_interval,
            sync_storage,
            client,
            formatter: entry_formatter,
        };

        let (malware_trie, e_tag) = match client.load_cached_malware_trie().await {
            Ok(Some(cached_info)) => {
                tracing::debug!(
                    "create new remote malware list (uri: {}) with cached trie",
                    client.uri
                );
                cached_info
            }
            Ok(None) => {
                tracing::debug!(
                    "no cached malware list found for remote endpoint (uri: {}); download fresh list",
                    client.uri
                );

                client
                    .download_malware_trie(None)
                    .await
                    .context("download new malware list")?
                    .context("new malware list not available")?
            }
            Err(err) => {
                tracing::warn!(
                    "failed to load cached malware list for remote endpoint (uri: {}); download fresh list; err = {err}",
                    client.uri
                );

                client
                    .download_malware_trie(None)
                    .await
                    .context("download new malware list")?
                    .context("new malware list not available")?
            }
        };

        let shared_malware_trie = Arc::new(ArcSwap::new(Arc::new(malware_trie)));

        tokio::spawn(remote_list_update_loop(
            guard,
            client,
            e_tag,
            shared_malware_trie.clone(),
        ));

        Ok(Self {
            trie: shared_malware_trie,
        })
    }
}

struct RemoteMalwareListClient<C> {
    uri: Uri,
    filename: ArcStr,
    refresh_interval: Duration,
    sync_storage: SyncCompactDataStorage,
    client: C,
    formatter: EntryFormatter,
}

impl<C> RemoteMalwareListClient<C>
where
    C: Service<Request, Output = Response, Error = BoxError>,
{
    async fn download_malware_trie(
        &self,
        e_tag: Option<&str>,
    ) -> Result<Option<(MalwareTrie, Option<ArcStr>)>, BoxError> {
        let Some((malware_list, new_e_tag)) =
            self.fetch_remote_malware_list_and_e_tag(e_tag).await?
        else {
            return Ok(None);
        };

        self.spawn_malware_list_caching_task(malware_list.clone(), new_e_tag.clone());

        let trie = trie_from_malware_list(malware_list, self.formatter.as_ref());

        tracing::debug!(
            "malware trie refreshed with link to remote endpoint '{}'",
            self.uri,
        );

        Ok(Some((trie, new_e_tag)))
    }

    async fn fetch_remote_malware_list_and_e_tag(
        &self,
        previous_e_tag: Option<&str>,
    ) -> Result<Option<(Vec<ListDataEntry>, Option<ArcStr>)>, BoxError> {
        let start = Instant::now();

        let req_builder = self.client.get(self.uri.clone());

        let req_builder = if let Some(e_tag) = previous_e_tag {
            req_builder.header("if-none-match", e_tag)
        } else {
            req_builder
        };

        let resp = req_builder
            .send()
            .await
            .context("fetch malware list from remote endpoint")
            .context_debug_field("tt", start.elapsed())
            .with_context_field("uri", || self.uri.clone())?;

        if resp.status() == StatusCode::NOT_MODIFIED {
            tracing::debug!(
                "malware list endpoint '{}' reported list is not found, return no new list; (tt: {:?})",
                self.uri,
                start.elapsed()
            );
            return Ok(None);
        }

        let e_tag: Option<ArcStr> = resp
            .headers()
            .get("etag")
            .and_then(|v| v.as_bytes().try_into().ok());

        let malware_list: Vec<ListDataEntry> = resp
            .try_into_json()
            .await
            .context("collect and json-decode malware list response payload from remote endpoint")
            .with_context_field("uri", || self.uri.clone())
            .with_context_debug_field("tt", || start.elapsed())?;

        tracing::debug!(
            "fetched and decoded and new malware list from remote endpoint '{}', with {} entries (tt: {:?})",
            self.uri,
            malware_list.len(),
            start.elapsed(),
        );

        Ok(Some((malware_list, e_tag)))
    }

    fn spawn_malware_list_caching_task(
        &self,
        malware_list: Vec<ListDataEntry>,
        e_tag: Option<ArcStr>,
    ) {
        let storage = self.sync_storage.clone();
        let filename = self.filename.clone();

        // backup in background,
        // only useful for making restarts faster and also
        // less error prone in case at the time the CDN is broken or w/e
        tokio::task::spawn_blocking(move || {
            if let Err(err) = storage.store(
                &filename,
                &CachedMalwareTrie {
                    e_tag: e_tag.clone(),
                    list: malware_list,
                },
            ) {
                tracing::error!("failed to backup downloaded malware list @ '{filename}': {err}")
            }
        });
    }

    async fn load_cached_malware_trie(
        &self,
    ) -> Result<Option<(MalwareTrie, Option<ArcStr>)>, BoxError> {
        tokio::task::spawn_blocking({
            let storage = self.sync_storage.clone();
            let filename = self.filename.clone();
            let formatter = self.formatter.clone();
            move || load_cached_malware_trie_sync_inner(storage, filename, formatter.as_ref())
        })
        .await
        .context("wait for blocking task to use cached malware list for creating new remote malware list")
        .with_context_field("uri", || self.uri.clone())?
    }
}

fn load_cached_malware_trie_sync_inner(
    storage: SyncCompactDataStorage,
    filename: ArcStr,
    formatter: &dyn MalwareListEntryFormatter,
) -> Result<Option<(MalwareTrie, Option<ArcStr>)>, BoxError> {
    let cached_malware_trie: Option<CachedMalwareTrie> =
        storage.load(&filename).context("storage failure")?;

    let Some(cached_malware_trie) = cached_malware_trie else {
        return Ok(None);
    };

    let trie = trie_from_malware_list(cached_malware_trie.list, formatter);

    Ok(Some((trie, cached_malware_trie.e_tag)))
}

async fn remote_list_update_loop<C>(
    guard: ShutdownGuard,
    client: RemoteMalwareListClient<C>,
    e_tag: Option<ArcStr>,
    shared_malware_trie: Arc<ArcSwap<MalwareTrie>>,
) where
    C: Service<Request, Output = Response, Error = BoxError>,
{
    tracing::debug!(
        "remote malware list (uri = {}), update loop task up and running",
        client.uri
    );

    let mut sleep_for = with_jitter(client.refresh_interval);
    let mut latest_e_tag = e_tag;

    loop {
        tracing::debug!(
            "remote malware list (uri = {}), sleep for: {sleep_for:?}",
            client.uri
        );
        tokio::select! {
            _ = tokio::time::sleep(sleep_for) => {},
            _ = guard.cancelled() => {
                tracing::debug!(
                    "remote malware list (uri = {}), guard cancelled; exit",
                    client.uri
                );
                return;
            }
        }

        match client.download_malware_trie(latest_e_tag.as_deref()).await {
            Ok(Some((fresh_trie, fresh_e_tag))) => {
                tracing::debug!(
                    "remote malware list (uri = {}), malware trie updated",
                    client.uri
                );
                shared_malware_trie.store(Arc::new(fresh_trie));
                sleep_for = with_jitter(client.refresh_interval);
                latest_e_tag = fresh_e_tag;
            }
            Ok(None) => {
                tracing::debug!("malware list was unmodified, preserve current one...");
                sleep_for = with_jitter(client.refresh_interval);
            }
            Err(err) => {
                tracing::error!(
                    "remote malware list (uri = {}), failed to update (err = {err}), try again in shorter interval...",
                    client.uri
                );
                let fail_interval = Duration::from_secs(std::cmp::max(sleep_for.as_secs() / 2, 60));
                sleep_for = with_jitter(fail_interval);
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
struct CachedMalwareTrie {
    pub e_tag: Option<ArcStr>,
    pub list: Vec<ListDataEntry>,
}

fn with_jitter(refresh: Duration) -> Duration {
    let max_jitter = std::cmp::min(refresh, Duration::from_secs(60));
    let jitter_secs = rand::rng().random_range(0.0..=max_jitter.as_secs_f64());
    refresh + Duration::from_secs_f64(jitter_secs)
}

fn trie_from_malware_list(
    malware_list: Vec<ListDataEntry>,
    formatter: &dyn MalwareListEntryFormatter,
) -> MalwareTrie {
    let mut trie = MalwareTrie::new();
    for list_entry in malware_list.into_iter() {
        let key = formatter.format(&list_entry);
        let entry = MalwareEntry {
            version: list_entry.version,
            reason: list_entry.reason,
        };
        match trie.get_mut(key.as_str()) {
            Some(entries) => entries.push(entry),
            None => {
                let _previous = trie.insert(key, vec![entry]);
                debug_assert!(
                    _previous.is_none(),
                    "trie::get_mut should have returned result if it already existed!"
                );
            }
        }
    }
    trie
}

pub struct MalwareEntriesResult<'a> {
    package_name: &'a str,
    guard: Guard<Arc<Trie<String, Vec<MalwareEntry>>>>,
}

impl MalwareEntriesResult<'_> {
    pub fn entries(&self) -> Option<&[MalwareEntry]> {
        self.guard.get(self.package_name).map(|v| v.as_slice())
    }
}

impl RemoteMalwareList {
    pub fn find_entries<'a>(&self, package_name: &'a str) -> MalwareEntriesResult<'a> {
        let guard = self.trie.load();
        MalwareEntriesResult {
            package_name,
            guard,
        }
    }

    pub fn has_entries_with_version(&self, package_name: &str, version: PackageVersion) -> bool {
        let entries = self.find_entries(package_name);
        let Some(entries) = entries.entries() else {
            return false;
        };

        entries.iter().any(|entry| entry.version.eq(&version))
    }
}

rama::utils::macros::enums::enum_builder! {
    @String
    pub enum Reason {
        Malware => "MALWARE",
        Telemetry => "TELEMETRY",
    }
}

pub type MalwareTrie = Trie<String, Vec<MalwareEntry>>;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct MalwareEntry {
    pub version: PackageVersion,
    pub reason: Reason,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ListDataEntry {
    pub package_name: String,
    pub version: PackageVersion,
    pub reason: Reason,
}

/// Display [`Uri`] as a appropriate string for a file name,
/// replacing all non-alphanumeric ASCII characters as an underscore `_`.
fn url_to_filename(url: &Uri) -> ArcStr {
    url.to_string()
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .into()
}

#[cfg(test)]
mod tests {
    use rama::utils::str::arcstr::arcstr;
    use serde_test::{Token, assert_de_tokens, assert_tokens};

    use crate::firewall::version::PragmaticSemver;

    use super::*;

    #[test]
    #[tracing_test::traced_test]
    fn test_url_to_filename() {
        let url = Uri::from_static("http://example.com/foo?bar=baz&answer=42");
        let filename = url_to_filename(&url);
        assert_eq!("http___example_com_foo_bar_baz_answer_42", filename);
    }

    #[test]
    #[tracing_test::traced_test]
    fn test_list_data_entry_without_version() {
        assert_de_tokens(
            &ListDataEntry {
                package_name: "package w/o version (implicit)".to_owned(),
                version: PackageVersion::None,
                reason: Reason::Malware,
            },
            &[
                Token::Struct {
                    name: "ListDataEntry",
                    len: 2,
                },
                Token::String("package_name"),
                Token::String("package w/o version (implicit)"),
                Token::String("reason"),
                Token::String("malware"),
                Token::StructEnd,
            ],
        )
    }

    #[test]
    #[tracing_test::traced_test]
    fn test_list_data_entry_ser_de() {
        for (tokens, entry) in [
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package with semver"),
                    Token::String("version"),
                    Token::Some,
                    Token::String("1.2.3"),
                    Token::String("reason"),
                    Token::String("test"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package with semver".to_owned(),
                    version: PackageVersion::Semver(PragmaticSemver::new_semver(1, 2, 3)),
                    reason: Reason::Unknown("test".to_owned()),
                },
            ),
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package @ any"),
                    Token::String("version"),
                    Token::Some,
                    Token::String("*"),
                    Token::String("reason"),
                    Token::String("TELEMETRY"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package @ any".to_owned(),
                    version: PackageVersion::Any,
                    reason: Reason::Telemetry,
                },
            ),
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package w/o version"),
                    Token::String("version"),
                    Token::Some,
                    Token::String(""),
                    Token::String("reason"),
                    Token::String("MALWARE"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package w/o version".to_owned(),
                    version: PackageVersion::None,
                    reason: Reason::Malware,
                },
            ),
            (
                vec![
                    Token::Struct {
                        name: "ListDataEntry",
                        len: 3,
                    },
                    Token::String("package_name"),
                    Token::String("package with unknown version"),
                    Token::String("version"),
                    Token::Some,
                    Token::String("V20-3020#32;123"),
                    Token::String("reason"),
                    Token::String("MALWARE"),
                    Token::StructEnd,
                ],
                ListDataEntry {
                    package_name: "package with unknown version".to_owned(),
                    version: PackageVersion::Unknown(arcstr!("V20-3020#32;123")),
                    reason: Reason::Malware,
                },
            ),
        ] {
            assert_tokens(&entry, &tokens);
        }
    }
}
